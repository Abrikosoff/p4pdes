#!/usr/bin/env python

help =\
'''
Plot trajectory, or frames if solution has two spatial dimensions, generated by
running a PETSc TS program.  Reads output from
   -ts_monitor binary:TFILE -ts_monitor_solution binary:YFILE
Requires access to bin/PetscBinaryIO.py and bin/petsc_conf.py, e.g. sym-links.
'''

# generate frames example:
#   $ ./heat -ts_monitor binary:t.dat -ts_monitor_solution binary:u.dat -ts_final_time 0.02 -ts_dt 0.001 -da_refine 6
#   $ ./plottrajectory.py -mx 193 -my 192 t.dat u.dat         # show at screen
#   $ ./plottrajectory.py -mx 193 -my 192 t.dat u.dat -o bar  # save files to bar%03d.png

# generate movie from frames using ffmpeg (ubuntu specific, probably):
#   $ sudo apt-get install ffmpeg         # might be needed
#   $ ffmpeg -r 4 -i bar%03d.png bar.m4v
#   $ totem var.m4v                       # vlc has trouble

import PetscBinaryIO

from sys import exit
from time import sleep
from argparse import ArgumentParser, RawTextHelpFormatter
import numpy as np
import matplotlib.pyplot as plt

parser = ArgumentParser(description=help,
                        formatter_class=RawTextHelpFormatter)
parser.add_argument('tfile',metavar='TDATA',
                    help='file from -ts_monitor binary:TDATA')
parser.add_argument('ufile',metavar='UDATA',
                    help='file from -ts_monitor_solution binary:UDATA')
parser.add_argument('-mx',metavar='MX', type=int, default=-1,
                    help='treat as spatial grid with MX points in x direction')
parser.add_argument('-my',metavar='MY', type=int, default=-1,
                    help='treat as spatial grid with MY points in y direction; MY=MX if missing')
parser.add_argument('-o',metavar='FILE',dest='filename',
                    help='save image file instead of showing figure in window; generates FILEXXX.png for XXX=000,001,... if spatial grid')
args = parser.parse_args()

if args.mx > 0 and args.my < 1:
    args.my = args.mx
frames = (args.mx > 0)

tfile = open(args.tfile,'r')
t = np.fromfile(tfile, dtype='>d')
tfile.close()

io = PetscBinaryIO.PetscBinaryIO()
U = np.array(io.readBinaryFile(args.ufile)).transpose()
dims = np.shape(U)

if len(t) != dims[1]:
    print 'time dimension mismatch: %d != %d' % (len(t),dims[1])
    exit(1)
if frames:
    if dims[0] != args.mx * args.my:
        print 'spatial dimension mismatch: %d != %d * %d' % \
              (dims[0],args.mx,args.my)
        exit(2)
    U = np.reshape(U,(args.my,args.mx,len(t)))
    dims = np.shape(U)
    print 'solution U is shape=(%d,%d,%d)' % tuple(dims)
    print 'time t is length=%d, with mx x my = %d x %d frames' % (dims[2],dims[1],dims[0])
else:
    print 'time t is length=%d, solution Y is shape=(%d,%d)' % \
          (len(t),dims[0],dims[1])

if frames:
    plt.imshow(U[:,:,0])
    plt.title('t = %g' % t[0])
    if args.filename:
        plt.savefig(args.filename + "%03d.png" % 0)
    else:
        plt.ion()
        plt.show()
    for k in range(len(t)-1):
        plt.imshow(U[:,:,k+1])
        plt.title('t = %g' % t[k+1])
        if args.filename:
            plt.savefig(args.filename + "%03d.png" % k)
        else:
            plt.pause(0.1)
else:
    for k in range(dims[0]):
        plt.plot(t,U[k],label='y[%d]' % k)
    plt.xlabel('t')
    plt.legend()
    if args.filename:
        plt.savefig(args.filename)
    else:
        plt.show()


static const char help[] =
"Build and explore a tiny three-triangle mesh using DMPlex.  Option prefix tny_.\n\n";

/* 
either build DMPlex via call to DMPlexCreateFromCellList() with interpolate=TRUE:
./tiny
or by directly setting cones "by hand":
./tiny -tny_by_hand

compare these views:  FIXME:  abstract out my "view" routines
./tiny -dm_view
./tiny -tny_ranges
./tiny -tny_ranges -tny_use_height
./tiny -tny_cones
./tiny -tny_supports
./tiny -tny_vec_view
*/

#include <petsc.h>
#include "plexview.h"

// describe mesh: triangle style with separate numbering for cells and vertices
static const int dim = 2,
                 ncell = 3,
                 nvert = 5,
                 cells[9] = {0, 3, 2,  // 9 = ncell * (dim+1)
                             0, 2, 1,
                             2, 3, 4};
static const double coordvert[10] = {0.0, 0.0,  // 10 = nvert * dim
                                     0.0, 1.0,
                                     0.5, 1.0,
                                     1.0, 0.0,
                                     1.0, 1.0};

// describe same mesh, but directly as DMPlex, i.e. by giving cones in DAG (or Hasse diagram)
// use ncell, nvert as above; these values (or equivalents) are generated by DMPlexCreateFromCellList()
static const int npoint = 15,
                 offedge = 8,
                 ccone[3][3] = {{8,9,10},
                                {10,11,12},
                                {9,13,14}},
                 econe[7][2] = {{3,6},
                                {5,6},
                                {3,5},
                                {4,5},
                                {3,4},
                                {6,7},
                                {5,7}};

extern PetscErrorCode CreateMeshByHand(DM*);

int main(int argc,char **argv) {
    PetscErrorCode ierr;
    DM            dmplex;
    PetscSection  section;
    PetscBool     by_hand = PETSC_FALSE,
                  cones = PETSC_FALSE,
                  use_height = PETSC_FALSE,
                  ranges = PETSC_FALSE,
                  supports = PETSC_FALSE,
                  vec_view = PETSC_FALSE;

    PetscInitialize(&argc,&argv,NULL,help);

    ierr = PetscOptionsBegin(PETSC_COMM_WORLD, "tny_", "options for tiny", "");CHKERRQ(ierr);
    ierr = PetscOptionsBool("-by_hand", "use by-hand construction",
                            "tiny.c", by_hand, &by_hand, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-cones", "print cones of each cell",
                            "tiny.c", cones, &cones, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-use_height", "use Height instead of Depth when printing points",
                            "tiny.c", use_height, &use_height, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-ranges", "print point index ranges for cells,edges,nodes",
                            "tiny.c", ranges, &ranges, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-supports", "print supports of each vertex",
                            "tiny.c", supports, &supports, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsBool("-vec_view", "print entries of a global vec for P2 elements",
                            "tiny.c", vec_view, &vec_view, NULL);CHKERRQ(ierr);
    ierr = PetscOptionsEnd();

    if (by_hand) {
        ierr = CreateMeshByHand(&dmplex); CHKERRQ(ierr);
    } else {
        // "interpolate" flag is PETSC_TRUE because it means "topologically
        // interpolate" i.e. create edges (1D) from cell (2D) and vertex (0D) info
        ierr = DMPlexCreateFromCellList(PETSC_COMM_WORLD,dim,ncell,nvert,dim+1,
            PETSC_TRUE,cells,dim,coordvert,&dmplex); CHKERRQ(ierr);
    }
    ierr = DMSetFromOptions(dmplex); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject) dmplex, "tiny mesh"); CHKERRQ(ierr);

    // viewing of dmplex
    ierr = DMViewFromOptions(dmplex, NULL, "-dm_view"); CHKERRQ(ierr);  // why not enabled by default?
    if (ranges) {
        ierr = PlexViewRanges(dmplex,PETSC_VIEWER_STDOUT_WORLD,use_height); CHKERRQ(ierr);
    }
    if (cones) {
        ierr = PlexViewFans(dmplex,PETSC_VIEWER_STDOUT_WORLD,PETSC_TRUE,"cell","edge",0,ncell); CHKERRQ(ierr);
    }
    if (supports) {
        ierr = PlexViewFans(dmplex,PETSC_VIEWER_STDOUT_WORLD,PETSC_FALSE,"vertex","edge",ncell,ncell+nvert); CHKERRQ(ierr);
    }

    // create dofs like P2 elements using PetscSection
    // with 1 dof on each node (depth==0) and 1 dof on each edge (depth==1)
    // [DMPlexCreateSection() seems to do something like the following]
    int  j, m, pstart, pend, nstart, nend, estart, eend;
    ierr = DMPlexGetChart(dmplex,&pstart,&pend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 0, &nstart, &nend); CHKERRQ(ierr);
    ierr = DMPlexGetDepthStratum(dmplex, 1, &estart, &eend); CHKERRQ(ierr);
    ierr = PetscSectionCreate(PETSC_COMM_WORLD,&section); CHKERRQ(ierr);
    ierr = PetscSectionSetChart(section, pstart, pend); CHKERRQ(ierr);
    for (j = nstart; j < nend; ++j) {
        ierr = PetscSectionSetDof(section, j, 1); CHKERRQ(ierr);
    }
    for (j = estart; j < eend; ++j) {
        ierr = PetscSectionSetDof(section, j, 1); CHKERRQ(ierr);
    }
    ierr = PetscSectionSetUp(section); CHKERRQ(ierr);
    ierr = DMSetDefaultSection(dmplex, section); CHKERRQ(ierr);

    // assign values in a global Vec for the section, i.e. on P2 dofs
    // FIXME a more interesting task would be to have an f(x,y), and attach
    // coordinates to the nodes, and evaluate an integral \int_Omega f(x,y) dx dy
    Vec    v;
    double *av;
    int    numpts, *pts = NULL, dof, off;

    ierr = DMGetGlobalVector(dmplex, &v); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject) v, "v"); CHKERRQ(ierr);
    ierr = VecSet(v,0.0); CHKERRQ(ierr);

    // FIXME Vec gets 1.0 for dofs on cell=1  <-- boring
    VecGetArray(v, &av);
    DMPlexGetTransitiveClosure(dmplex, 1, PETSC_TRUE, &numpts, &pts);
    for (j = 0; j < 2 * numpts; j += 2) {  // skip over orientations
        PetscSectionGetDof(section, pts[j], &dof);
        PetscSectionGetOffset(section, pts[j], &off);
        for (m = 0; m < dof; ++m) {
            av[off+m] = 1.0;
        }
    }
    DMPlexRestoreTransitiveClosure(dmplex, 1, PETSC_TRUE, &numpts, &pts);
    VecRestoreArray(v, &av);

    if (vec_view) {
        Vec coords;
        ierr = VecView(v,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
        ierr = DMGetCoordinates(dmplex,&coords); CHKERRQ(ierr);
        if (coords) {
            ierr = VecView(coords,PETSC_VIEWER_STDOUT_WORLD); CHKERRQ(ierr);
        } else {
            ierr = PetscPrintf(PETSC_COMM_WORLD,
                "[vertex coordinates have not been set]\n"); CHKERRQ(ierr);
        }
    }
    ierr = DMRestoreGlobalVector(dmplex, &v); CHKERRQ(ierr);

    PetscSectionDestroy(&section); DMDestroy(&dmplex);
    return PetscFinalize();
}


/* this function is equivalent to DMPlexCreateFromCellList(); see implementation in
DMPlexBuildFromCellList_Private(), DMPlexInterpolate(), and DMPlexBuildCoordinates_Private()
see also  DMPlexCreateFromCellListParallel() */
PetscErrorCode CreateMeshByHand(DM *dmplex) {
    PetscErrorCode ierr;
    int           d, j;
    PetscSection  coordSection;
    DM            cdm;
    Vec           coordinates;
    double        *acoord;
    ierr = DMPlexCreate(PETSC_COMM_WORLD,dmplex); CHKERRQ(ierr);
    // set the total number of points (ncell+nvert+nedges)
    ierr = DMPlexSetChart(*dmplex, 0, npoint); CHKERRQ(ierr);
    // the points are cells, nodes, edges in that order, and we only set cones for cells and edges
    for (j = 0; j < ncell; j++) {
        ierr = DMPlexSetConeSize(*dmplex, j, dim+1); CHKERRQ(ierr);
    }
    for (j = offedge; j < npoint; j++) {
        ierr = DMPlexSetConeSize(*dmplex, j, dim); CHKERRQ(ierr);
    }
    ierr = DMSetUp(*dmplex);
    for (j = 0; j < ncell; j++) {
        ierr = DMPlexSetCone(*dmplex, j, ccone[j]); CHKERRQ(ierr);
    }
    for (j = offedge; j < npoint; j++) {
        ierr = DMPlexSetCone(*dmplex, j, econe[j-offedge]); CHKERRQ(ierr);
    }
    // with cones we have only upward directions and no labels for the strata
    // (note: both Symmetrize & Stratify are required, and they must be in this order
    ierr = DMPlexSymmetrize(*dmplex); CHKERRQ(ierr);
    ierr = DMPlexStratify(*dmplex); CHKERRQ(ierr);
    ierr = DMSetDimension(*dmplex,dim); CHKERRQ(ierr);
    // you have to setup the PetscSection returned by DMGetCoordinateSection() first,
    // or else the Vec returned by DMCreateLocalVector() has zero size
    // (and thus seg faults)
    ierr = DMGetCoordinateSection(*dmplex, &coordSection); CHKERRQ(ierr);
    ierr = PetscSectionSetNumFields(coordSection, 1); CHKERRQ(ierr);
    ierr = PetscSectionSetFieldComponents(coordSection, 0, dim); CHKERRQ(ierr);
    ierr = PetscSectionSetChart(coordSection, ncell, ncell+nvert); CHKERRQ(ierr);
    for (j = ncell; j < ncell+nvert; j++) {
        ierr = PetscSectionSetDof(coordSection, j, dim); CHKERRQ(ierr);
        ierr = PetscSectionSetFieldDof(coordSection, j, 0, dim); CHKERRQ(ierr);
    }
    ierr = PetscSectionSetUp(coordSection); CHKERRQ(ierr);
    // now we can actually set up the coordinate Vec
    ierr = DMGetCoordinateDM(*dmplex, &cdm); CHKERRQ(ierr);
    ierr = DMCreateLocalVector(cdm, &coordinates); CHKERRQ(ierr);
    ierr = VecSetBlockSize(coordinates,dim); CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject) coordinates, "coordinates"); CHKERRQ(ierr);
    ierr = VecGetArray(coordinates, &acoord); CHKERRQ(ierr);
    for (j = 0; j < nvert; j++) {
        for (d = 0; d < dim; ++d) {
            acoord[j*dim+d] = coordvert[j*dim+d];
        }
    }
    ierr = VecRestoreArray(coordinates, &acoord); CHKERRQ(ierr);
    // finally we tell the DM that it has coordinates
    ierr = DMSetCoordinatesLocal(*dmplex, coordinates); CHKERRQ(ierr);
    VecDestroy(&coordinates);
    return 0;
}


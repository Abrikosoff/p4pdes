#!/usr/bin/env python
#
# (C) 2018 Ed Bueler
#
# Create PETSc binary files .vec,.is from ascii .msh mesh file generated by Gmsh.
# This script is based on reading the ASCII format documented at
#   http://gmsh.info/doc/texinfo/gmsh.html#MSH-ASCII-file-format
# Note that one could use existing Python libraries such as
#   https://pypi.org/project/pygmsh/
# to interact with Gmsh, but instead this simple script avoids the dependency.

# example: put PETSc Vec with locations (node coordinates x,y) in meshes/trap.vec
# and PETSc ISs (e,bfn,s,bfs) in meshes/trap.is
#    $ gmsh -2 meshes/trap.geo
#    $ ./msh2petsc.py meshes/trap.msh

from __future__ import print_function

import numpy as np
import sys

# debug print
VERBOSITY=5;  # set to large value to see messages
def dprint(d,s):
    if d < VERBOSITY:
        print(s)

def fail(k,s):
    print('ERROR: %s ... stopping' % s)
    sys.exit(k)

def check_mesh_format(filename):
    with open(filename, 'r') as mshfile:
        MFread = False
        numsread = False
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$MeshFormat':
                    if MFread:
                        print('WARNING: "$MeshFormat" repeated')
                    MFread = True
                elif line.split(' ') == ['2.2','0','8']:
                    if numsread:
                        print('WARNING: Gmsh format version number etc. repeated')
                    numsread = True
                elif line == '$EndMeshFormat':
                    continue
        return (MFread and numsread)

def read_nodes(filename):
    with open(filename, 'r') as mshfile:
        Nodesread = False
        EndNodesread = False
        N = 0   # number of nodes
        count = 0
        coords = []
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$Nodes':
                    if Nodesread:
                        fail(2,'"$Nodes" repeated')
                    Nodesread = True
                elif line == '$EndNodes':
                    if not Nodesread:
                        fail(3,'"$EndNodes" before "$Nodes"')
                    if len(coords) < 2:
                        fail(4,'"$EndNodes" reached before any nodes read')
                    if count != N:
                        fail(5,'N does not agree with index')
                    break  # apparent success reading the nodes
                elif Nodesread:
                    ls = line.split(' ')
                    if len(ls) == 1:
                        if N != 0:
                            fail(6,'N found but already read')
                        try:
                            N = int(ls[0])
                        except ValueError:
                            fail(7,'N not an integer')
                        if N <= 0:
                            fail(8,'N invalid')
                        coords = np.zeros(2*N)  # allocate space for nodes
                        dprint(1,'N=%d' % N)
                    else:
                        if N == 0:
                            fail(9,'expected to read N by now')
                        try:
                            rcount = int(ls[0])
                        except ValueError:
                            fail(10,'node index not an integer')
                        if count+1 != rcount:
                            fail(11,'unexpected (noncontiguous?) node indexing')
                        count += 1
                        try:
                            xy = map(float,ls[1:3])
                        except ValueError:
                            fail(12,'could not convert node coordinates to float')
                        coords[2*(count-1):2*count] = xy            
    if count != N:
        fail(13,'N should equal count of read nodes')
    return coords

if __name__ == "__main__":
    import argparse
    import PetscBinaryIO
    # need link to petsc/bin/petsc-pythonscripts/PetscBinaryIO.py

    parser = argparse.ArgumentParser(description= \
        'Converts .msh ASCII file from Gmsh into PETSc binary files .vec,.is.')
    # required positional filename
    parser.add_argument('inname', metavar='FILE',
                        help='input file name with .msh extension')
    args = parser.parse_args()

    if args.inname.split('.')[-1] == 'msh':
        outroot = '.'.join(args.inname.split('.')[:-1]) # strip .msh
    else:
        print('WARNING: expected .msh extension for input file')
    vecoutname = outroot + '.vec'
    isoutname = outroot + '.is'

    print('  checking mesh format in input file %s ...' % args.inname)
    if not check_mesh_format(args.inname):
        print('ERROR: mesh format not as expected ... stopping')
        sys.exit(1)

    print('  reading node coordinates from %s ...' % args.inname)
    xycoords = read_nodes(args.inname)

    print('  writing node coordinates as PETSc Vec to %s ...' % vecoutname)
    petsc = PetscBinaryIO.PetscBinaryIO()
    petsc.writeBinaryFile(vecoutname,[xycoords.view(PetscBinaryIO.Vec),])

    print('  reading element tuples from %s ...' % args.inname)
    # FIXME
    #print('  writing FIXME as PETSc Vec to %s ...' % vecoutname)
    #petsc.writeBinaryFile(args.outroot+'.is',[oe,obfn,os,obfs])


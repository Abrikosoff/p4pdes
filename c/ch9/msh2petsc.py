#!/usr/bin/env python
#
# (C) 2018 Ed Bueler
#
# Create PETSc binary files .vec,.is from ascii .msh mesh file generated by Gmsh.
# This script is based on reading the ASCII format documented at
#   http://gmsh.info/doc/texinfo/gmsh.html#MSH-ASCII-file-format
# Note that one could use existing Python libraries such as
#   https://pypi.org/project/pygmsh/
# to interact with Gmsh, but instead this simple script avoids the dependency.

# example: put PETSc Vec with locations (node coordinates x,y) in meshes/trap.vec
# and PETSc ISs (e,bfn,s,bfs) in meshes/trap.is
#    $ gmsh -2 meshes/trap.geo
#    $ ./msh2petsc.py meshes/trap.msh

from __future__ import print_function

import numpy as np
import sys

# debug print
def dprint(debug,s):
    if debug:
        print(s)

def fail(k,s):
    print('ERROR: %s ... stopping' % s)
    sys.exit(k)

def check_mesh_format(filename):
    MFread = False
    numsread = False
    with open(filename, 'r') as mshfile:
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$MeshFormat':
                    if MFread:
                        print('WARNING: "$MeshFormat" repeated')
                    MFread = True
                elif line.split(' ') == ['2.2','0','8']:
                    if numsread:
                        print('WARNING: Gmsh format version number etc. repeated')
                    numsread = True
                elif line == '$EndMeshFormat':
                    continue
        return (MFread and numsread)

def read_physical_names(filename):
    PNread = False
    nPN = 0
    physical = {}   # empty dictionary
    with open(filename, 'r') as mshfile:
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$PhysicalNames':
                    PNread = True
                elif line == '$EndPhysicalNames':
                    break
                elif PNread:
                    ls = line.split(' ')
                    if nPN == 0 and len(ls) == 1:
                        try:
                            nPN = int(ls[0])
                        except ValueError:
                            fail(2,'nPN not an integer')
                    else:
                        assert (len(ls) == 3), 'expected three items on line'
                        try:
                            dim = int(ls[0])
                        except ValueError:
                            fail(2,'dim not an integer')
                        try:
                            num = int(ls[1])
                        except ValueError:
                            fail(2,'num not an integer')
                        physical[ls[2].strip('"')] = num
    assert (nPN == len(physical)), 'expected number of physical names does not equal number read'
    return physical

def read_nodes(filename):
    Nodesread = False
    EndNodesread = False
    N = 0   # number of nodes
    count = 0
    coords = []
    with open(filename, 'r') as mshfile:
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$Nodes':
                    assert (not Nodesread), '"$Nodes" repeated'
                    Nodesread = True
                elif line == '$EndNodes':
                    assert (Nodesread), '"$EndNodes" before "$Nodes"'
                    assert (len(coords) >= 2), '"$EndNodes" reached before any nodes read'
                    assert (count == N), 'N does not agree with index'
                    break  # apparent success reading the nodes
                elif Nodesread:
                    ls = line.split(' ')
                    if len(ls) == 1:
                        assert (N == 0), 'N found again but already read'
                        try:
                            N = int(ls[0])
                        except ValueError:
                            fail(7,'N not an integer')
                        assert (N > 0), 'N invalid'
                        coords = np.zeros(2*N)  # allocate space for nodes
                    else:
                        assert (N > 0), 'expected to read N by now'
                        try:
                            rcount = int(ls[0])
                        except ValueError:
                            fail(10,'node index not an integer')
                        count += 1
                        assert (count == rcount), 'unexpected (noncontiguous?) node indexing'
                        try:
                            xy = map(float,ls[1:3])
                        except ValueError:
                            fail(12,'could not convert node coordinates to float')
                        coords[2*(count-1):2*count] = xy            
    assert (count == N), 'N should equal count of read nodes'
    return coords

if __name__ == "__main__":
    import argparse
    import PetscBinaryIO
    # need link to petsc/bin/petsc-pythonscripts/PetscBinaryIO.py

    parser = argparse.ArgumentParser(description= \
        'Converts .msh ASCII file from Gmsh into PETSc binary files .vec,.is.')
    # required positional filename
    parser.add_argument('-v', default=False, action='store_true',
                        help='verbose output for debugging')
    parser.add_argument('inname', metavar='FILE',
                        help='input file name with .msh extension')
    args = parser.parse_args()

    if args.inname.split('.')[-1] == 'msh':
        outroot = '.'.join(args.inname.split('.')[:-1]) # strip .msh
    else:
        print('WARNING: expected .msh extension for input file')
    vecoutname = outroot + '.vec'
    isoutname = outroot + '.is'

    print('  checking mesh format in input file %s ...' % args.inname)
    if not check_mesh_format(args.inname):
        print('ERROR: mesh format not as expected ... stopping')
        sys.exit(1)

    print('  reading physical names ...')
    phys = read_physical_names(args.inname)
    dprint(args.v,phys)

    print('  reading node coordinates ...')
    xycoords = read_nodes(args.inname)
    dprint(args.v,'N=%d' % (len(xycoords)/2))
    dprint(args.v,xycoords)

    print('  writing node coordinates as PETSc Vec to %s ...' % vecoutname)
    petsc = PetscBinaryIO.PetscBinaryIO()
    petsc.writeBinaryFile(vecoutname,[xycoords.view(PetscBinaryIO.Vec),])

    print('  reading element tuples ...')
    # FIXME
    #print('  writing FIXME as PETSc Vec to %s ...' % vecoutname)
    #petsc.writeBinaryFile(args.outroot+'.is',[oe,obfn,os,obfs])


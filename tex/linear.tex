
\chapter{2. Linear PDEs with matrix methods}

We start with a cliched example, the Poisson problem, because it is the right place to start.  Though the Poisson problem is a cliche in applied mathematics, it gives us the opportunity to use \PETSc for important tasks, including reading an unstructured mesh into \PETSc \pVec s, preallocation of a \pMat in parallel, and use of a linear solver (a \pKSP object) to solve large sparse systems.

\section{The Poisson problem}

Let $\Omega \subset \RR^d$ be a region.  Suppose its boundary is decomposed into well-behaved subsets $\partial_D \Omega$ and $\partial_N \Omega$ whose union is the entire boundary $\partial \Omega$.  The \emph{Poisson problem}, in strong form and including nonhomogeneous Dirichlet and Neumann boundary conditions, is\marginnote{%
\begin{tikzpicture}[scale=0.7]
%\draw[gray,very thin] (-2,-6) grid (8,3);
\draw[line width=2pt] (0,0) .. controls (0,3) and (5,3) .. node[sloped,above] {$u=g$} node[sloped,below] {$\partial_D\Omega$} (7,0);
\draw[line width=0.75pt] (7,0) .. controls (9,-2) and (-1,-7) .. node[sloped,above] {$\partial_N\Omega$} node[sloped,below] {$\partial u/\partial n = \gamma$} (-1,-5);
\draw[line width=0.75pt] (-1,-5) .. controls (-1,-4) and (2,-5) .. (2,-3);
\draw[line width=0.75pt] (2,-3) .. controls (2,-1) and (0,-3) .. (0,0);
\draw[->,line width=1.0pt] (2,-3) -- (1.2,-3) node[below] {$\bn$}; % normal vector
\draw (4,-1) node {$- \grad^2 u = f$ in $\Omega$};
\end{tikzpicture}}
\begin{align}
- \grad^2 u &= f \quad \text{ on } \Omega, \label{poissonstrong} \\
u &= g \quad \text{ on } \partial_D \Omega, \notag \\
\frac{\partial u}{\partial n} &= \gamma \quad \text{ on } \partial_N \Omega \notag
\end{align}
where $\partial u/\partial n = \bn \cdot \grad u$ and $\bn$ is the outward unit normal on $\partial \Omega$.  The data of problem \eqref{poissonstrong}, besides the region $\Omega$ and its boundary, includes a \emph{source term} $f\in L^2(\Omega)$, \emph{Dirichlet data} $g\in L^2(\partial_N \Omega)$, and \emph{Neumann data} $\gamma\in L^2(\partial_N \Omega)$.

This Poisson problem models the distribution of temperature in a conducting object at steady state, the electrostatic potential, the equilibrium distribution from certain random walks, and many other other physical phenomena.  And it is linear, that is, if $u_1$ and $u_2$ are solutions then convex linear combinations are also solutions.  More relevantly, it is a linear problem in the sense that finite-dimensional approximations of the Poisson problem are simply matrix problems.

As \eqref{poissonstrong} is stated there may be no solution where ``$\grad^2 u$'' makes sense as a function, even for ``nice'' boundary and source functions.  In particular, there may be no $u\in C^2(\Omega)$ which is continuous up to the boundary (i.e.~$u\in C(\bar\Omega)$).  There is, however, a solution\sidenote{Many mathematical concepts, including a well-posedness proof that justifies this claim, are all covered by \citep{Evans}.  These are technicalities for us.  Our goal is computational performance in cases where the Poisson problem is mathematically well-behaved.} if we change to a \emph{weak formulation}.  Furthermore, if $\partial_D \Omega$ has positive measure then the solution is unique.  We will state the weak formulation after defining function spaces.

Recalling $L^2(\Omega)$ is the space of all square-integrable real functions on $\Omega$, define
    $$H^1(\Omega) = \{u\in L^2(\Omega) \big| \grad u \text{ exists a.e.~and } \grad u \in L^2(\Omega)\},$$
which is a Sobolev space \citep{Evans}.  This space has two subsets we will use, namely functions with value $g$ on $\partial_D \Omega$ and those with value $0$ on $\partial_D \Omega$, respectively, which we denote $H_g^1(\Omega)$ and $H_0^1(\Omega)$.  Note that $H_0^1(\Omega)$ is a linear subspace of $H^1(\Omega)$ while $H_g^1(\Omega)$ is generally not a subspace, because the zero function is not in it.  Nonetheless, from now on we refer to both $H_g^1(\Omega)$ and $H_0^1(\Omega)$ as ``subspaces''.

To get to the weak formulation of the Poisson problem we choose any $v\in H_0^1(\Omega)$, multiply the first equation in \eqref{poissonstrong} by $v$, and integrate by parts:
\begin{equation*}
\int_\Omega \grad u \cdot \grad v - \int_{\partial\Omega} \frac{\partial u}{\partial n} v = \int_\Omega f v.
\end{equation*}
Suppose\marginnote{%
{\color{red}Main ideas} of strong and weak formulations:\begin{itemize}
\item If $u \in H_g^1(\Omega)$ solves the strong form \eqref{poissonstrong} then it solves \eqref{poissonweak} also.
\item If $u \in H_g^1(\Omega)$ solves the weak form \eqref{poissonweak} then we accept it, by definition, as a solution of the Poisson problem.\end{itemize}} we already have a classical solution $u\in H_g^1(\Omega)$ of \eqref{poissonstrong}.  Then we use the other data, namely that $v=0$ on $\partial_D\Omega$ and that there is Neumann data $\gamma$ on $\partial_N\Omega$, in the above equation:
\begin{equation}
\int_\Omega \grad u \cdot \grad v = \int_\Omega f v + \int_{\partial_N\Omega} \gamma v\quad \text{ for any } v\in H_0^1(\Omega). \label{poissonweak}
\end{equation}

Equation \eqref{poissonweak} is the \emph{weak formulation} of the Poisson problem, and $u \in H_g^1(\Omega)$ satisfying \eqref{poissonweak}, if it exists, is called a \emph{weak solution}.  A key observation is that $u$ itself incorporates the Dirichlet boundary condition, because it lives in $H_g^1(\Omega)$, while both the Neumann boundary data $\gamma$ and the source function $f$ appear in equation \eqref{poissonweak}.


\section{A finite element method for the Poisson problem}

A \emph{finite element method} (FEM) for the Poisson problem comes from requiring the weak formulation \eqref{poissonweak} to be true for $u$ in a much smaller, indeed finite-dimensional, subspace of $H_g^1(\Omega)$.  Also $v$ will range over a finite-dimensional subspace of $H_0^1(\Omega)$.  In our case these subspaces will be essentially the same, so our method is a \emph{Galerkin} FEM.  We will build these finite-dimensional subspaces, in the current example, using an unstructured triangulation on $\Omega\subset \RR^2$.  In particular, from now on in this chapter we restrict to $d=2$ dimensions.  Furthermore, to make our finite-dimensional spaces true subspaces of $H^1(\Omega)$---to make our FEM \emph{conforming}---we also require that $\Omega$ be polygonal, with $\partial\Omega$ a closed polygon.  We require that the segments in $\partial\Omega$ each have positive length, and be either entirely in $\partial_D\Omega$ or entirely in $\partial_N\Omega$.

By definition, a \emph{triangulation} is a set of non-overlapping, non-empty open triangles $\triangle_k\subset \RR^2$ which tile $\Omega$:
\begin{equation*}
\Th = \left\{\triangle_k \quad\Big|\quad \cup_k \overline{\triangle}_k = \overline{\Omega} \quad \text{ and} \quad \Omega_k \cap \Omega_l = \emptyset \text{ if } k\ne l\right\}.
\end{equation*}
We index the $K$ triangles in $\Th$ by $k=0,\dots,K-1$.  (In contrast to \citet{Elmanetal2005}, which we generally follow but which implements in \Matlab, our indexing is always zero-based.  After all, we code in C.)  An example is shown in Figure \ref{fig:number-elements}.  The subscript ``$h$'' in $\Th$ is traditional; it denotes the typical or maximum size $h$ (e.g.~diameter) of the triangles.  It serves as a reminder that we want to solve the Poisson problem accurately, that is, in the limit $h\to 0$.

\begin{marginfigure}
\input{samplepoly.1.tikz}
\caption{A triangulation $\Th$ with $K=22$ triangles (elements) numbered $k=0,1,\dots,K-1$ ({\color{red} red}) and $N=16$ nodes numbered $j=0,1,\dots,N-1$  ({\color{blue} blue}).  Nodes $\bx_0$, $\bx_1$, $\bx_2$, $\bx_3$ are in the Dirichlet boundary $\partial_D\Omega$.}
\label{fig:number-elements}
\end{marginfigure}

The vertices (nodes) in the triangulation are indexed by $j=0,1,\dots,N$ and their planar locations are the key geometric information in a triangulation:
\begin{equation*}
\bx_j = (x_j,y_j).
\end{equation*}
An example of this node indexing is also in Figure \ref{fig:number-elements}.

We will informally call the triangles \emph{elements}, though there is more to the definition of ``element.''  We are going to approximate the Poisson problem with $\Pone$ finite elements, which means that our finite-dimensional subspace contains only piecewise-linear functions which are linear on each triangle $\triangle_k$.

For each node $j$ there is a $\Pone$ basis function, or ``hat'' function, $\phi_j(x,y)$ which is linear on each triangle, continuous on all of $\overline{\Omega}$, and equal to one on only one node $j$:\marginnote{%
\begin{tikzpicture}[scale=0.9, z={(.707,.3)}]
    % (2,2,1) is top
    \draw[style=dashed] (0,0,0) -- (2,2,1); % to top from left
    \draw[style=dashed] (4,0,0) -- (2,2,1); %   ...  from front
    \draw[style=dashed] (4,0,3) -- (2,2,1); %   ...  from right
    \draw[color=gray, style=dashed] (0.3,0,4) -- (2,2,1); % from back
    \draw[color=gray, style=dashed] (2,0.4,1) -- (2,2,1); % from middle
    % draw base
    \draw (0,0,0) -- (4,0,0);
    \draw (4,0,0) -- (4,0,3);
    \draw[color=gray] (0,0,0) -- (0.3,0,4);
    \draw[color=gray] (0.3,0,4) -- (4,0,3);
    \draw[color=gray] (0,0,0) -- (2,0.4,1);
    \draw[color=gray] (2,0.4,1) -- (4,0,3);
    \draw[color=gray] (4,0,0) -- (2,0.4,1);
    \draw[color=gray] (2,0.4,1) -- (0.3,0,4);
    % draw \phi_j at nodes
    \filldraw (2,2,1) circle (1.25pt);
    \draw (2,2.5,1) node {$\phi_j(\bx_j)=1$};
    \draw (2,0.15,1) node {$\bx_j$};
    \filldraw (0,0,0) circle (1.25pt);
    \filldraw (4,0,0) circle (1.25pt);
    \draw (4,-0.5,0) node {$\phi_j(\bx_i)=0$};
    \draw (4.1,0.3,0) node {$\bx_i$};
    \filldraw (4,0,3) circle (1.25pt);
    \filldraw[color=gray] (0.3,0,4) circle (1.25pt);
\end{tikzpicture}
}%
\begin{equation*}
\phi_j(\bx_i) = \delta_{ij}.
\end{equation*}
The functions $\phi_j$ are in $H^1(\Omega)$, with piecewise-constant partial derivatives $\partial\phi_j/\partial x$ and $\partial\phi_j/\partial y$.  Also, the set $\{\phi_j\}_{j=0,\dots,N-1}$ is linearly-independent.  On each triangle, $\phi_j$ has three degrees of freedom.  That is, on $\triangle_k$ there exists coefficients $A_k,B_k,C_k\in\RR$ so that
\begin{equation*}
\phi_j(x,y) = A_k + B_k x + C_k y \quad \text{ on } \triangle_k.
\end{equation*}

We can immediately use these basis functions to approximate the Dirichlet data $g$ and ``extend'' it to the region $\Omega$.  We will assume from now on that the Dirichlet boundary $\partial_D\Omega$ is closed.  Then we index the $L$ nodes which are in the Dirichlet boundary, $\bx_{j_l} \in \partial_D\Omega$ for $l=0,\dots,L-1$.  (Figure \ref{fig:number-elements} shows an example with $L=4$ and $j_l=l$ for $l=0,1,2,3$, but a general index is allowed as long as the index values $j_l$ are well-defined.)  Now we can define an extended interpolant $\hat g$ of $g$ as the function which has the correct value on the Dirichlet boundary nodes and which extends to all of $\Omega$ in a continuous and piecewise-linear way:
\begin{equation}
\hat g(x,y) = \sum_{l=0,\dots,L} g(\bx_{j_l}) \phi_{j_l}(x,y). \label{hatgdefine}
\end{equation}

By using $\hat g$ and the basis functions $\phi_j$, we can now describe three finite-dimensional subspaces of $H^1(\Omega)$:\sidenote{Traditionally, basis functions for $S_g^h$ are called the \emph{trial} functions, and basis functions for $S_0^h$ are called \emph{test} functions.  We will generally just use the labels ``$S_g^h$'' and ``$S_0^h$.''}
\begin{align*}
S^h &= \Span\{\phi_j \,\big|\, \text{ all } j\,\}, \\
S_0^h &= \Span\{\phi_j \,\big|\, \bx_j \notin \partial_D \Omega\} \subset S^h, \\
S_g^h &= S_0^h + \hat g \subset S^h.
\end{align*}
Then $\dim(S^h)=N$ while $\dim(S_0^h)=\dim(S_g^h)=N-L$, with $S_g^h$ now clearly defined as an affine subspace of $S^h$.

Finally, our finite element method requires that the weak formulation  \eqref{poissonweak} be true of $u_h\in S_g^h$ for all $v\in S_0^h$.  Thus we first write $u_h$ in the basis for $S_g^h$ using $N-L$ unknown coefficients $u_j$:
\begin{equation}
u_h(x,y) = \hat g(x,y) + \sum_{\bx_j \notin \partial_D \Omega} u_j\, \phi_j(x,y). \label{uhexpand}
\end{equation}
Then we require that the weak formulation hold for all $\phi_i$ in the basis of $S_0^h$.  That is, using definition \eqref{hatgdefine} and expansion \eqref{uhexpand}, we require
\begin{align}
\sum_{j\big|\bx_j \notin \partial_D \Omega} u_j \int_\Omega \grad \phi_j \cdot \grad \phi_i &= \int_\Omega f \phi_i + \int_{\partial_N\Omega} \gamma \phi_i \label{poissonfem} \\
&\qquad - \sum_{l=0,\dots,L} g(\bx_{j_l})  \int_\Omega \grad \phi_{j_l} \cdot \grad \phi_i \notag
\end{align}
for all $i$ such that $\bx_i \notin \partial_D \Omega$.  The coefficients $u_j$, for all $j$ such that $\bx_j \notin \partial_D \Omega$, are the unknowns in this equation.

Note that the support (i.e.~nonzero set) of $\phi_j$ includes only the node $\bx_j$ and all triangles (elements) $\triangle_k$ for which $\bx_j$ is a node of $\triangle_k$.  Thus the integral ``$\int_\Omega \grad \phi_j \cdot \grad \phi_i$'' in \eqref{poissonfem} is often zero.  Specifically, it is zero if nodes $\bx_i$ and $\bx_j$ are not connected by an edge in the triangulation, equivalently if $\bx_i$ and $\bx_j$ are not both nodes of at least one triangle in the triangulation.



\section{Getting a triangular mesh into \PETSc}

We now take a break from mathematical constructions to do something practical with \PETSc.  While \PETSc itself does not include any tools for triangulating regions of the plane, we use the widely-available and easy-to-use \Triangle software \citep{Shewchuk1996} for this task.\sidenote{See \href{http://www.cs.cmu.edu/~quake/triangle.html}{www.cs.cmu.edu/$\sim$quake/ triangle.html} for documentation and source code of \Triangle. You can build it from source, but it is probably available as a package in your operating system.}  \Triangle, which is both limited to planar regions and only capable of writing ASCII files, is not a choice for performance.  It is convenient.

\Triangle uses a simply-formatted ASCII file with extension \texttt{.poly} as input to describe a polygonal region $\Omega$ and to indicate the Dirichlet and Neumann portions of $\partial \Omega$.  For example, consider the input file \texttt{bump.poly} shown in Figure \ref{code:bumppoly}. 

\inputfromline{../c/bump.poly}{bump.poly}{A description of the boundary polygon in Figure \ref{fig:triangulation}, suitable for reading by \Triangle.}{16}{code:bumppoly}

This example polygon, a rectangle with a triangular bump in the base, is shown in Figure \ref{fig:bump-poly}.  It will reappear several times in these notes as we solve more and more interesting PDEs on it.

\begin{marginfigure}
\input{bump.poly.tikz}
\caption{The polygon described in \texttt{bump.poly}.  The bold part is the Dirichlet boundary.}
\label{fig:bump-poly}
\end{marginfigure}

The triangulation shown in Figure \ref{fig:triangulation} came from a single command which asks \Triangle to take \texttt{bump.poly} and generate a triangulation which is quality-checked \citep{Shewchuk1996} (option \texttt{-q}), which has triangles with maximum area of $1.0$ (option \texttt{-a1.0}), and including a polygon output file (option \texttt{-p}):
\begin{verbatim}
  $ triangle -pqa1.0 bump
\end{verbatim}
This command generates three ASCII files, \texttt{bump.1.poly}, \texttt{bump.1.node}, and  \texttt{bump.1.ele}.  These files define the new (i.e.~refined relative to \texttt{bump.poly}) polygonal boundary, the nodes locations, and the elements of the triangulation, respectively.  For example, \texttt{bump.1.node} has the numbering and node locations shown in blue in Figure \ref{fig:triangulation}.

\begin{figure*}
\input{bump.1.tikz}
\caption{A FEM triangulation generated by \Triangle.  Nodes are labeled by $j=0,\dots,N-1$ with $N=24$.}
\label{fig:triangulation}
\end{figure*}

As noted, \Triangle produces ASCII files.  This is not a good format for large meshes.  Because we intend to rapidly read large meshes before solving large PDE problems in a scalable way with \PETSc, we now do a mundane and un-scalable task in \PETSc.  Namely we read the \Triangle files serially onto a single processor and write out a binary file in \PETSc format.  The code \texttt{c2convert.c} which does this is invoked, for the present purposes, by
\begin{verbatim}
  $ c2convert -f bump.1
\end{verbatim}
This reads ASCII files \texttt{bump.1.poly}, \texttt{bump.1.node}, and \texttt{bump.1.ele}.  Then it writes out a \PETSc-formatted binary file \texttt{bump.1.petsc}.

We show the code \texttt{c2convert.c} in detail.  It starts with a standard preamble shown in Figure  \ref{code:trianglepartone}.  We will omit showing this preamble for future codes, but this preamble, or a subset of it, appears in all of them. In this preamble we see how \PETSc is initialized, and how to, for instance, learn which rank is the current processor.

\cinputpart{c2convert.c}{The standard preamble.}{I}{//STARTPREAMBLE}{//ENDPREAMBLE}{code:trianglepartone}

The next part of \texttt{c2convert.c} is in Figure \ref{code:triangleparttwo}.  Here we use the pair \texttt{PetscOptionsBegin}/\texttt{PetscOptionsEnd} to bracket the reading of the two options we need, namely for the string containing the filename root, and for a flag which determines whether \texttt{c2convert.c} will read back its \texttt{.petsc} output as a check.  This \texttt{...Begin}/\texttt{...End} pair allows \PETSc to give a helpful message, describing the options for various components including the application code, when we run ``\texttt{c2convert -h}''.

\cinputpart{c2convert.c}{Determine filenames using \PETSc option processing.}{II}{//ENDPREAMBLE}{//ENDFILENAME}{code:triangleparttwo}

The third part of \texttt{c2convert.c} is in Figure \ref{code:trianglepartthree}.  Starting here we only ask the first process (``rank zero'') in the MPI communicator to do any work.  Thus, if invoked ``\texttt{mpiexec -n NN c2convert},'' this code will run at the same speed regardless of the value of \texttt{NN}, because it is actually a serial code.  This part of the code reads the header information in the \texttt{.node} file, and allocates \PETSc \pVec s according.

\cinputpart{c2convert.c}{Start to read ASCII files with \textsc{triangle}-generated mesh by going to rank zero processor, reading node header, allocate accordingly, and read nodes.}{III}{//ENDFILENAME}{//ENDREADNODES}{code:trianglepartthree}

Then we read the node locations from the \texttt{.node} file.  It is read into sequential \PETSc \pVec s which have been allocated (created) only on the rank zero process.  The reading itself is done with the standard C library call \texttt{fscanf}, and then \texttt{VecSetValues} from \PETSc is used to set one \pVec entry at a time.  After setting these values, which is just the storage of a list of values in an internal \PETSc dynamic array used for assembling \pVec s, we actually ask \PETSc to do the assembly.  This is done so often that we put it in a C preprocessor macro, as shown in the short header \texttt{convenience.h} listed in Figure \ref{code:convenience}.

\inputwhole{../c/convenience.h}{convenience.h}{Some definitions.}{code:convenience}

The next part of \texttt{c2convert.c} is in Figure \ref{code:trianglepartfour}.  This looks like the previous part, because we read boundary polygon information from the \texttt{.poly} file.  Specifically, each segment of the boundary polygon corresponds to two node indices.  We store these in a \pVec with blocksize 2.

\cinputpart{c2convert.c}{On rank zero processor: Read polygon information.}{IV}{//ENDREADNODES}{//ENDREADPOLYGONS}{code:trianglepartfour}

The next part, shown in Figure \ref{code:trianglepartfive}, might be the most important.  We build a single \pVec which contains all the information about each element that is needed to do the matrix equation assembly for that element.  In particular, we reads the node indices for each element from the \texttt{.ele} file.  Then we fill this C \texttt{struct}, which is the size of 12 \texttt{PetscScalars}:
\begin{Verbatim}
    typedef struct {
      PetscScalar j[3],  // global indices of nodes j[0], j[1], j[2]
                  BT[3], // boundary type of node:  BT[0], BT[1], BT[2]
                  x[3],  // node x-coordinate x[0], x[1], x[2]
                  y[3];  // node y-coordinate y[0], y[1], y[2]
    } element;
\end{Verbatim}
(Unfortunately, a \PETSc \pVec is designed to hold \texttt{PetscScalar} data types, i.e.~\texttt{double} in most cases, and so we are quite wasteful for integer indices.)  Thus we build a \pVec with blocksize 12.

\cinputpart{c2convert.c}{On rank zero processor: Read element indices  Build element data structure, i.e.~a \pVec with blocksize 12.}{V}{//ENDREADPOLYGONS}{//ENDREADELEMENTS}{code:trianglepartfive}

At this point we have the whole triangulation in \PETSc \pVec s.  Now is the easy and last part of \texttt{c2convert.c}, shown in Figure \ref{code:trianglepartsix}.  We simply create a \PETSc ``viewer'' and ``view'' all of the \pVec s which contain the mesh.  We will be able to reread these \pVec s in parallel, as long as we re-read them in the same order.

\cinputpart{c2convert.c}{On rank zero processor: Write the mesh out in \PETSc binary format.}{VI}{//ENDREADELEMENTS}{//ENDRANK0}{code:trianglepartsix}



\section{The FEM matrix problem}

Now that we can get a triangulation into \PETSc, we can return to the finite-dimensional weak formulation \eqref{poissonfem}.  It is simply a matrix equation, and we will write code which builds \PETSc \pMat and \pVec objects to store this problem, and then we will use a \PETSc \pKSP object to solve it.

For ease of construction we will include the node-wise Dirichlet conditions as rows of this matrix problem, so the matrix will have $N$ columns, corresponding to one unknown for \emph{every} node $\bx_j$, and $N$ rows.  We will then describe, and give a code for, \emph{assembling} this matrix equation.

Thus we define $A \in \RR^{N\times N}$ to have entries
\begin{equation*}
a_{ij} = \int_\Omega \grad \phi_j \cdot \grad \phi_i,
\end{equation*}
if $\bx_i \notin \partial_D \Omega$ and $\bx_j \notin \partial_D \Omega$.  Otherwise
\begin{equation*}
a_{ij} = \delta_{ij},
\end{equation*}
that is, in any row $i$ where $\bx_i \in \partial_D \Omega$ or column $j$ where $\bx_j \in \partial_D \Omega$.  (Notice that we index rows and columns of matrices and vectors starting with zero.)

We can immediately observe that $A$ is \emph{symmetric} because $a_{ij}=a_{ji}$.  Furthermore it is \emph{sparse}, that is, most entries are zero, as long as we consider triangulations with more than a handful of triangles.  These facts have profound consequences on the algorithms we will choose when solving a matrix equation
\begin{equation}
A \bu = \bb \label{poissonmatrix}
\end{equation}
using $A$.

Recalling \eqref{poissonfem}, the right side of our matrix equation ``$A \bu = \bb$'' will be a vector $\bb\in\RR^N$ with entries
    $$b_i = \int_\Omega f \phi_i + \int_{\partial_N\Omega} \gamma \phi_i - \sum_{l=0,\dots,L} g(\bx_{j_l})  \int_\Omega \grad \phi_{j_l} \cdot \grad \phi_i$$
if $\bx_i \notin \partial_D \Omega$ and
    $$b_i = g(\bx_{i})$$
if $\bx_i \in \partial_D \Omega$.

However, in practice we don't initially build $A$ quite as described in above.  We will initially build a matrix $\tilde A$ which ignors the type (i.e.~Dirichlet or Neumann) of the boundary nodes and computes all entries by the first formula above for $a_{ij}$.  That is, $\tilde A \in \RR^{N\times N}$ has entries
\begin{equation*}
\tilde a_{ij} = \int_\Omega \grad \phi_j \cdot \grad \phi_i
\end{equation*}
for all $i,j=0,1,\dots,N$.  Also we initially compute a right-hand side $\tilde \bb$ with simpler entries
    $$\tilde b_i = \int_\Omega f \phi_i + \int_{\partial_N\Omega} \gamma \phi_i$$
if $\bx_i \notin \partial_D \Omega$ and
    $$\tilde b_i = g(\bx_{i})$$
if $\bx_i \in \partial_D \Omega$.  Then we ``edit'' $\tilde A$ in each Dirichlet node \emph{row}, that is, for each $i$ where $\bx_i \in \partial_D \Omega$, simply by replacing the whole row by the corresponding row of the identity.  However, in each column $j$ for which $\bx_j \in \partial_D \Omega$, we move all entries $\tilde a_{ij}$ where $i$ is \emph{not} a Dirichlet row index, over to the right-hand side, multiplied by the negative of the boundary value $g(\bx_{j})$; informally we can write
    $$\tilde b_i \to \tilde b_i - g(\bx_{j}) \tilde a_{ij}$$
for the transformations which modify the initial version $\tilde \bb$.

After this ``editing'' stage is completed for all Dirichlet rows and columns, we get $A$ and $\bb$.  Since this part of the matrix assembly is a key stage of understanding our FEM codes, we give a concrete example to show the non-zero pattern of $A$.

\medskip\noindent\hrulefill
\begin{example} In Figure \ref{fig:squarefour} there are five nodes.  The $i=1,2$ nodes live in the (closed) Dirichlet boundary $\partial_D \Omega$.  The matrix $\tilde A$ has zero entries $\tilde a_{ij} = 0$ only where the integral $\int_\Omega \grad \phi_j \cdot \grad \phi_i=0$, which is somewhat rare in this small (coarse)-mesh case.  The nonzero values are simply marked ``$\X$'', and the zero entries are spaces:\begin{marginfigure}
\input{squarefour.tikz}
\caption{A triangulation of a square with five nodes.  The top segment is the Dirichlet boundary.}
\label{fig:squarefour}
\end{marginfigure}%
\begin{equation*}
\tilde A = \begin{bmatrix}
\X & \X &    & \X & \X \\
\X & \X & \X &    & \X \\
   & \X & \X & \X & \X \\
\X &    & \X & \X & \X \\
\X & \X & \X & \X & \X
\end{bmatrix}.
\end{equation*}
Now we color the $i=1,2$ or $j=1,2$ entries which will be edited:\marginnote{{\color{red} Potential gotcha}:  The first row of any matrix in this book is numbered ``$0$.''  Likewise the first column.}
\begin{equation*}
\tilde A = \begin{bmatrix}
\X & \redX &    & \X & \X \\
\blueX & \blueX & \blueX &    & \blueX \\
   & \blueX & \blueX & \blueX & \blueX \\
\X &    & \redX & \X & \X \\
\X & \redX & \redX & \X & \X
\end{bmatrix}.
\end{equation*}
The {\color{blue} blue} entries are changed to $0$ or $1$ so that these rows become rows of the identity; their computed values are tossed out.  The {\color{red} red} entries, specifically the four entries $\tilde a_{01}$, $\tilde a_{32}$, $\tilde a_{41}$, and $\tilde a_{42}$, are moved over to the right side, however, so their values are used.  In fact, we can give formulas for the $i=0,3,4$ entries of the final vector $\bb$ in terms of the initially-computed vector $\tilde\bb$,
\begin{align*}
b_0 &= \tilde b_0 - g(\bx_1) \tilde a_{01} \\
b_3 &= \tilde b_3 - g(\bx_2) \tilde a_{32} \\
b_4 &= \tilde b_4 - g(\bx_1) \tilde a_{41} - g(\bx_2) \tilde a_{42},
\end{align*}
while $b_1=\tilde b_1=g(\bx_1)$ and $b_2 = \tilde b_2 = g(\bx_2)$.  The final matrix $A$ has thereby been ``edited'' to be the identity matrix in rows $i=1,2$ and columns $j=1,2$; it has this pattern:
\begin{equation*}
A = \begin{bmatrix}
\X & & & \X & \X \\
 & \,1\, & & & \\
 & & \,1\, & & \\
\X & & & \X & \X \\
\X & & & \X & \X
\end{bmatrix}.
\end{equation*}
\end{example}
\noindent\hrulefill

\bigskip

In terms of later examples, we can note that the initial construction is already correct in the case where $\partial_D \Omega$ is the empty set.  In this Neumann-only case $A=\tilde A$ and $\bb = \tilde \bb$.  However, in this case it is also true that $u=(\text{constant})$ solves $-\grad^2 u=0$ with $\partial u/\partial n = 0$ on the whole boundary $\partial_N \Omega = \partial \Omega$, so equations \eqref{poissonstrong} or \eqref{poissonweak} only determines the solution up to an additive constant.  Thus the Poisson problem does not have a unique solution in this case, and we will have to tell \PETSc about the extra constant solutions, i.e.~the null space.


\section{Assembling the matrix equation, element by element}

Each entry $\tilde a_{ij}$ of the initial matrix $\tilde A$ is not, however, computed in whole.  Rather, we compute contributions to these entries from each element.  To explain such element-by-element assembly we first define the integral over just one triangle $\triangle_k$:
    $$\tilde a_{ij}^k = \int_{\triangle_k} \grad \phi_j \cdot \grad \phi_i.$$
For each triangle $\triangle_k$ we assume that the three vertices are identified by local indices $q=0,1,2$.  Also we introduce an index function $P(k,q)$ for a triangulation which gives the (global) node index $j$ from the element index $k$ and the local index $q$:
    $$j=P(k,q) \in \{0,1,\dots,N-1\}.$$
Of course we can think of $P$ as an array with integer entries, $K$ rows, and 3 columns.

Denoting $\tilde a_{ij}^k$ by \texttt{a(k,i,j)}, to make the element-by-element assembly procedure clear we now give an assembly pseudocode for $\tilde A$:
\begin{verbatim}
A = 0                     // N x N matrix; set a(i,j) = 0
for k = 0 to K-1 {        // loop through all elements
  for q = 0 to 2 {        // loop through vertices of element k
    i = P(k,q)            // row index
    for r = 0 to 2 {
      j = P(k,r)          // column index
      a(i,j) += a(k,i,j)  // add contribution from element k
    }
  }
}
\end{verbatim}
To create a real code, however, we need to both compute $\tilde a_{ij}^k=$\texttt{a(k,i,j)} concretely, and implement the ``editing'' strategy which turns $\tilde A$ into $A$.  We address the former actions next, and leave the latter for an actual code below.

FIXME
\begin{align*}
\chi_0(\xi,\eta) &= 1-\xi-\eta \\
\chi_1(\xi,\eta) &= \xi \\
\chi_2(\xi,\eta) &= \eta
\end{align*}

$$\phi_i(x(\xi,\eta),y(\xi,\eta)) = \chi_i(\xi,\eta)$$

\begin{marginfigure}
\begin{tikzpicture}[scale=1.1,
    decoration={
      markings,
      mark=at position 1 with {\arrow[scale=1.8,gray]{latex}};
    }]
% left x,y axes
    \draw[->, gray, very thin] (1.5,0) -- (4.0,0);
    \draw[->, gray, very thin] (2,-0.5) -- (2,2.4);
    \draw (4.1,-0.1) node {$x$};
    \draw (1.9,2.4) node {$y$};
    \filldraw (1.7,1) circle (1.25pt);    % (x_0,y_0)
    \filldraw (3.5,-0.3) circle (1.25pt); % (x_1,y_1)
    \filldraw (3.0,2.0) circle (1.25pt);  % (x_2,y_2)
    \draw (1.4,1.3) node {$(x_0,y_0)$};
    \draw (3.5,-0.6) node {$(x_1,y_1)$};
    \draw (3.0,2.3) node {$(x_2,y_2)$};
    \draw[line width=1pt] (1.7,1) -- (3.5,-0.3) -- (3.0,2.0) -- cycle;
    \draw (2.7,1.0) node {$\triangle_k$};
% right xi,eta axes
    \draw[->, gray, very thin] (4.6,0) -- (6.6,0);
    \draw[->, gray, very thin] (5,-0.4) -- (5,2.0);
    \draw (6.7,-0.1) node {$\xi$};
    \draw (4.9,2.05) node {$\eta$};
    \filldraw (5,0) circle (1.25pt);  % (0,0)
    \filldraw (6,0) circle (1.25pt);  % (1,0)
    \filldraw (5,1) circle (1.25pt);  % (0,1)
    \draw (6.3,0.2) node {$(1,0)$};
    \draw (5.4,1.2) node {$(1,0)$};
    \draw[line width=1pt] (5,0) -- (6,0) -- (5,1) -- cycle;
    \draw (5.3,0.3) node {$\triangle_\ast$};
% arcs connecting nodes
\draw[gray, postaction={decorate}] (5,0) -- (1.7,1.03);
\draw[gray, postaction={decorate}] (6,0) -- (3.5,-0.3);
\draw[gray, postaction={decorate}] (5,1) -- (3.0,2.0);
%\draw[thin, gray] (5,0) .. controls (4.7,0.4) and (2.0,1.1) .. (1.7,1);
\end{tikzpicture}
\medskip
\caption{Mapping of a $\Pone$ element $\triangle_k$ from the reference element $\triangle_\ast$.}
\label{fig:isoparametric}
\end{marginfigure}


\section{Preallocate a \pMat}

FIXME: key idea is that we cannot tell if an edge is in the boundary just by whether both endpoints are in the boundary; i.e. we need to have list of boundary nodes which marks the boundary polygon

%\cinputpart{poissontools.c}{FIXME}

\cinputpart{c2testprealloc.c}{Read mesh \pVec s from file.  Get row ownership range.}{I}{//STARTLOAD}{//ENDLOAD}{code:testpreallocpartone}


\cinputpart{readmesh.c}{A method to determine the filename of \PETSc binary file that has the mesh, and a method to read one \pVec from a file.}{I}{//STARTGET}{//ENDGET}{code:readmeshpartone}

\cinputpart{readmesh.c}{Read the mesh from the file.  Then put a sequential copy of each mesh \pVec on each processor.}{II}{//STARTREADMESH}{//ENDREADMESH}{code:readmeshparttwo}


\cinputpart{c2testprealloc.c}{Set up \pMat $A$ and actually preallocate it.  Fill it with junk entries so the pattern can be visualized.}{II}{//ENDLOAD}{//ENDTEST}{code:testpreallocparttwo}


\section{Performance: convergence and scaling}



\caveat{But real-world PDEs are nonlinear.}

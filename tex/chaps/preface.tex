
\section{Why read this book?}

This book is about numerically solving linear and nonlinear partial differential equations (PDEs) by writing C code \citep{KernighanRitchie1988} that directly calls \PETSc.  It tries to both explain the ideas and illustrate them through example codes.  The examples come with enough background information and context so that readers can use them as a basis for further developments.  Demonstrated performance and scalability are goals, so runtime options are explained and compared, and explored in the exercises.

The inside front cover lists the PDE problems covered in this book, according the Chapter in which they appear.  These problems are thus not organized by following any of the traditions of the substantial PDE literature \citep[for just a start]{Evans2010,Ockendonetal2003}.  Instead, roughly-speaking, the problems appear in the order in which it is easiest to appreciate the needed algorithms and components from \PETSc.

The reader experienced with PDEs will note an absence of purely-hyperbolic problems \citep[compare][]{LeVeque2002}.  This reflects the current book's focus on problems in which (large) linear and nonlinear systems of equations must be solved, at each time-step or to compute steady state solutions, in the contex where one wants solutions at scale.

This book is written from the conviction that \emph{better access to common knowledge among experts} advances scientific computing as a discipline.  An expert in PDEs and \PETSc might say, about this book, both that ``I knew all that'' and that the book ``is a fast on-ramp to what I already know.''  Such is precisely my hope.

So, let's suppose you have taken a mathematics course or two in partial differential equations (PDEs).  You have written a few codes in C or \Matlab or Python etc.  You are interested in numerically-solving PDE problems in parallel on big machines.  Then this book is for you.

\section{What is \PETSc?}

The Portable, Extensible Toolkit for Scientific computing (\PETSc)\sidenote{Say it ``pets sea.''  The homepage for PETSc, including download and installation instructions, is \href{http://www.mcs.anl.gov/petsc/index.html}{www.mcs.anl.gov/petsc}.} is an open-source, mathematical software library built on top of the standard software layer for large-scale parallel computation, namely the Message Passing Interface (MPI) \citep{Groppetal1999}.  It is a framework capable of solving problems such as PDEs at ``large scale,'' that is, at high resolution and on supercomputers with hundreds to millions of cores.  \PETSc also runs on your laptop or workstation; that is where all examples from this book should be tried first.

\PETSc is not particularly new.  Version 2.0, the first version to make an impact in the scientific computing world, was developed in 1994.  A well-known monograph \citet{Smithetal1996} uses \PETSc 2.0 for scalable solutions of linear PDEs.  That book focusses on pre-conditioned iterative linear solvers and domain decomposition.  For example, methods such as additive Schwarz are shown to scalably-solve the Poisson equation on irregular domains.

But \PETSc is now at version \PETSCVERSION.  It has evolved into a more powerful toolbox with a much richer API (application program interface).  Typical examples and applications are for nonlinear PDEs.  Nonlinear, multigrid, and even multiphysics\sidenote{This buzzword refers to a diverse system of coupled PDEs with nontrivial scalings among the variables.} parts of the API are now highly-visible to users.

The modern \PETSc strategy is to combine (``compose'') time-steppers, Newton's method, and grid/mesh tools with preconditioners and iterative linear solvers, so that all of these structures are visible and controllable from the command line.\sidenote{Explaining the meaning of this last sentence is my (book-length) purpose.}  Navigating this algorithmic ``stack,'' reflected by a confusing plethora of run-time options, requires much broader user knowledge than did the computer tools of a generation ago.

In summary, \PETSc may not be a silver bullet, but it presents users with many powerful tools for solving difficult problems, well beyond iterative linear algebra.  A new book, introducing \PETSc to new users who already know something about PDEs, is appropriate.


\section{What I need from you, the reader}

To make sense of this book, some of the mathematical theory and practice of PDEs must be familiar.  \citet{Evans2010} and \citet{Ockendonetal2003} are recommended for this background, but they are not really prerequisites in the usual sense.  I will assume that the reader has some \emph{practical intuition} about PDE problems---should I use the term ``maturity''?---including exposure to nonlinear problems.  Of course, all applied mathematicians, distinctly including the author, are wanting when it comes to having good intuition for nonlinear PDEs.

Multiple numerical discretization paradigms will arise here.  At least one such numerical approach to PDEs should already be in the reader's toolbox.  That might be the finite element method (FEM) \citep{Braess2007,Elmanetal2005,KarniadakisSherwin2013}, finite differences \citep{LeVeque2007,MortonMayers2005}, or finite volumes \citep{LeVeque2002}.  (Spectral methods \citep{Trefethen2000} are outside of our scope.)  Previous exposure to multigrid ideas \citep{Briggsetal2000} would be helpful, but the concepts will be reviewed as we approach this key topic.

Many ideas from numerical linear algebra \citep{Greenbaum1997,TrefethenBau1997} will appear, often with only brief introduction.  The definitions of vector norms and (induced) matrix norms, along with the LU and Cholesky decompositions, are assumed.  In fact the textbook by \citet{TrefethenBau1997} is the closest, of the above-mentioned texts, to an actual prerequisite for this book.

Starting in Chapter \ref{chap:un} I will assume that you are interested in working with unstructured grids, though not at the exclusion of structured-grid approaches.  Basics of the FEM method will be reviewed in Chapters \ref{chap:of}, \ref{chap:un}, and \ref{chap:dp}, but the reader with some background understanding will benefit most.  Priority topics for a reader's FEM review include the weak form of a PDE and the idea of assembling the equations element-by-element.


\section{There is much that this book does NOT do}

Although there are many other uses of \PETSc, this book assumes you want to solve PDEs.  It attempts to get you started from no previous knowledge of \PETSc, and it samples some of the many good ideas for numerically solving PDEs.  However, this book\begin{itemize}
\item  does not seriously help you install \PETSc,
\item  does not replace either the \PETSc \emph{User's Manual}, or online searches of the \PETSc manual pages, for understanding the API,
\item  does not help with most of the (many) packages \PETSc links to,
\item  does not use Fortran or C++,\sidenote{All examples are in C, utilizing ANSI C99 features.}
\item  does not do a complete job of teaching the FEM or any other discretization paradigm for PDEs,
\item  does not seriously address whether its numerical solutions are effective models of physical problems,
\item  does not consider spatial dimensions beyond three,
\item  does not prove anything of any consequence,\sidenote{Theorems are stated precisely when appropriate.  In computational examples we give evidence for convergence and scalability, when possible, not just pretty pictures of putative solutions.} and
\item  does not adequately cover what is known about PDEs, much less what is not known.
\end{itemize}


\section{At the command line}

Before we really get started, what ``computer skills'' are assumed?  In summary, it is something more than what you need to get started with \Matlab, but certainly less than professional programmer abilities.  The programming here is stereotyped C coding using a modest language subset.

You need to have written and compiled C programs before.   Running and modifying the examples will inevitably expose some subtleties of the C language, but no more than would appear in a first college course in computer programming using C or a similar language.  Concepts of compiling and linking, of including header files, of passing arguments by value and pointer,\sidenote{The C language has no ``pass-by-reference'' syntax, but such is the usual intent when passing a pointer value.} should all be familiar.  We make constant use of two pointer ``concepts:'' arrays-as-pointers and output arguments which are pointer variables.

Of course, doing the exercises or modifying the examples will inevitably require attention to compile-time errors.  The ability to run codes within a debugger is, therefore, recommended knowledge.

Using \PETSc's installation and configuration process, e.g.~following instructions at
\begin{quote}
\href{http://www.mcs.anl.gov/petsc/documentation/installation.html}{\texttt{www.mcs.anl.gov/petsc/documentation/installation.html}},
\end{quote}
is required before compiling and running the examples in this book.  This process finds the compiler and enables ``\texttt{make}'' as a build command, or it fails.\sidenote{The \PETSc team will help with failed installation attempts.  See \href{http://www.mcs.anl.gov/petsc/documentation/bugreporting.html}{\texttt{www.mcs.anl.gov/petsc/ documentation/bugreporting.html}}.}  After installing and configuring \PETSc, the examples included with this book can be compiled by simply typing ``\texttt{make}'' at the command line in the appropriate \texttt{c/chN/} directory; see Chapter \ref{chap:gs}.  All examples in this book were built and run with the GNU C compiler ``\texttt{gcc}'' (\href{https://gcc.gnu.org/}{\texttt{gcc.gnu.org}}).

Searching in the \PETSc HTML manual pages for the various commands and data types, online at
\begin{quote}
\href{http://www.mcs.anl.gov/petsc/documentation/index.html}{\texttt{www.mcs.anl.gov/petsc/documentation/index.html}}
\end{quote}
or downloaded with the \PETSc source, should be one of the reader's first actions for resolving compile-time errors.  The reader should review the \emph{\PETSc User's Manual} \citep{petsc-user-ref}; it explains best why the API is designed in the way it is.

Finally, this book assumes a Bash shell---see  \href{https://www.gnu.org/software/bash/bash.html}{\texttt{www.gnu.org/software/ bash/bash.html}}---or a shell that interprets Bash syntax.  Uses of Bash syntax are mostly trivial, but examples of ``for loop'' syntax appear every once in a while:
\begin{cline}
$ for N in 1 2 3; do echo "count is $N"; done
count is 1
count is 2
count is 3
\end{cline}


To the reader who has become lost in the maze of issues which have built up around the examples so far---Krylov solvers, preconditioner choices, line searches, finite element details, or whatever causes confusion---some good news.  In \emph{this} Chapter we restart with an easy question and a small example.

After all, solving \emph{ordinary} differential equations (ODEs) with \PETSc ought to be easy.  Given that we have practice with \PETSc objects, it is.  So is making the transition to numerical methods for time-dependent, parabolic PDEs like the heat equation.  In fact, in this Chapter we look at three examples:
\begin{itemize}
\item a linear system of two ODEs,
\item an arbitrarily-large system of ODEs arising from spatial finite-difference approximation of the time-dependent heat PDE,
\item and another large ODE system arising from two coupled nonlinear PDEs which form a two-species reaction/diffusion model.
\end{itemize}

These time-dependent problems are solved using a new \PETSc object, a \pTS time-stepping solver, but the particular integration method can be chosen at run-time.  We will recall the basics of both \emph{explicit} and \emph{implicit} time-stepping techniques.  Because an implicit choice implies the full stack of \pSNES/\pKSP/\pPC solvers for the (generally) non-linear equations at each time step, our experience with examples from Chapters \ref{chap:st}--\ref{chap:of} will all be useful in the implicit case.

Our \emph{method of lines} approach for the two PDE examples above avoids any need to write code specific to the temporal discretization of those PDEs.  The third example above is, however, the first \emph{system} of PDEs addressed so far.  Describing such a system using \PETSc calls requires new choices in the code.


\section{ODEs and \PETSc \pTS objects}

Consider an ODE system in form
\begin{equation}
\by' = \bg(t,\by)  \label{eq:ts:ode}
\end{equation}
where $\by(t) \in \RR^N$ and $\by'=\by'(t)$ denotes $d\by/dt$, and suppose
\begin{equation}
\by(t_0) = \by_0  \label{eq:ts:ode:iv}
\end{equation}
gives an \emph{initial value}.

It is well-known that under reasonable assumptions on the behavior of $g$, the continuum problem \eqref{eq:ts:ode}, \eqref{eq:ts:ode:iv} is a well-posed problem.  That is, it is a problem from which one can make precise predictions forward (or backward) in time, \emph{at least for some short time into the future (or past)} from $t_0$, supposing that the integration to solve the ODE is performed exactly.

To be specific about regularity of $\bg$ which implies well-posedness, we assume for simplicity that $\bg(t,\by)$ is continuous around the initial point $(t_0,\by_0)$, say in a domain
   $$\mathcal{D} = \{(t,\by) \,:\, t_0 \le t \le t_f, |\by - \by_0| \le \omega\}$$
where $\omega > 0$.  We also assume that $\bg$ has additional regularity in its second argument, in the \emph{Lipshitz} sense that output differences bounded proportional to input differences: there is $L\ge 0$ so that
   $$\|\bg(t,\by_1) - \bg(t,\by_0)\| \le L \|\by_1-\by_0\|$$
on $\mathcal{D}$.  FIXME cite

FIXME example problem

FIXME intro numerical esp RK and theta \citep{AscherPetzold1998}

FIXME introduce \pTS, which contains \pSNES inside (and thus the rest)

FIXME build all tools around the ``hard'' time dependent case of stiff + nonlinear, though not DAE

FIXME function $\bg$ is \texttt{TSSetRHSFunction()}, Jacobian $\partial \bg/\partial \by$ is \texttt{TSSetRHSJacobian()}

FIXME show \texttt{ode.c}, which is most similar to \texttt{ecjacobian.c}

\clearpage
\newpage
\cinputpart{ode.c}{\CODELOC}{FIXME}{I}{//CALLBACKS}{//ENDCALLBACKS}{code:ts:ode:callbacks}

\cinputpart{ode.c}{\CODELOC}{FIXME}{II}{//MAIN}{//ENDMAIN}{code:ts:ode:main}

FIXME control \texttt{euler,beuler,cn,theta} by setting steps

FIXME control \texttt{rk} by \texttt{-ts\_type rk -ts\_atol Z -ts\_rk\_type XX}

FIXME generate figures by, and explain usage, \texttt{PetscBinaryIO.py}

\section{Time-dependent heat equation}

FIXME solve heat equation by implicit

\cinputpart{heat.c}{\CODELOC}{FIXME}{I}{//HEATCTX}{//ENDHEATCTX}{code:ts:heat:heatctx}

\cinputpart{heat.c}{\CODELOC}{FIXME}{II}{//RHSFUNCTION}{//ENDRHSFUNCTION}{code:ts:heat:rhsfunction}

\cinputpart{heat.c}{\CODELOC}{FIXME}{III}{//RHSJACOBIAN}{//ENDRHSJACOBIAN}{code:ts:heat:rhsjacobian}

\cinputpart{heat.c}{\CODELOC}{FIXME}{IV}{//TSSETUP}{//ENDTSSETUP}{code:ts:heat:tssetup}

\cinputpart{heat.c}{\CODELOC}{FIXME}{V}{//MONITOR}{//ENDMONITOR}{code:ts:heat:monitor}

\begin{figure}
% usage: \standardstack{scale}{objective}{Jacobian}{TS}{DMDA}{DMPlex}
\standardstack{0.775}{dashed}{}{}{}{dashed}
\caption{The \PETSc stack used for the time-dependent heat and reaction/diffusion problems (\texttt{heat.c,pattern.c}).  Compare Figure \ref{fig:of:standardstack}.  FIXME: \pSNES not directly seen by user code}
\label{fig:of:tsstack}
\end{figure}

FIXME show \texttt{-ts\_type theta,beuler,cn}


\section{Coupled reaction-diffusion equations}

FIXME see pages 21--22 of \citep{HundsdorferVerwer2003} and see \citep{Pearson1993}

\cinputpart{pattern.c}{\CODELOC}{FIXME}{I}{//FIELDCTX}{//ENDFIELDCTX}{code:ts:pattern:fieldctx}

\cinputpart{pattern.c}{\CODELOC}{FIXME}{II}{//RHSFUNCTION}{//ENDRHSFUNCTION}{code:ts:pattern:rhsfunction}

\cinputpart{pattern.c}{\CODELOC}{FIXME}{III}{//IFUNCTION}{//ENDIFUNCTION}{code:ts:pattern:ifunction}

\cinputpart{pattern.c}{\CODELOC}{FIXME}{IV}{//IJACOBIAN}{//ENDIJACOBIAN}{code:ts:pattern:ijacobian}

\cinputpart{pattern.c}{\CODELOC}{FIXME}{V}{//TSSETUP}{//ENDTSSETUP}{code:ts:pattern:tssetup}

FIXME show use of \texttt{-ts\_type arkimex,theta}

FIXME final-time greyscale plots using \texttt{PetscBinaryIO.py}


\section{Exercises}

\renewcommand{\labelenumi}{\arabic{chapter}.\arabic{enumi}\quad}
\renewcommand{\labelenumii}{(\alph{enumii})}
\begin{enumerate}
\item FIXME which \texttt{-ts\_type} work with \texttt{ode.c}?
% euler, beuler, rk, theta, cn
\item FIXME \texttt{ode.c} says it is ``serial only''  what happens with \texttt{mpiexec -n 2 ./ode}, and why?
\item FIXME version of \texttt{ode.c} which solves DAE system
    $$\bbf(t,\by,\by') = \bg(t,\by)$$
where $\partial \bg/\partial \by'$ may be singular
\item FIXME for run like
\begin{cline}
./pattern -da_refine 6 -ptn_tf 500 -ptn_steps 100 -ts_monitor -snes_converged_reason
\end{cline}
which is fastest among these nine ARKIMEX and three $\theta$ methods?:
\begin{code}
-ts_type arkimex -ts_arkimex_type [a2|l2|ars122|2c|2d|2e|3|4|5]
-ts_type theta -ts_theta_endpoint -ts_theta_theta [0.5|0.75|1]
\end{code}
Are any other adaptive \pTS types faster?  Also compare final frames from \texttt{-ts\_monitor\_solution draw}; how worried should we be about the effect of time-stepping on the solution of this problem?
\end{enumerate}
